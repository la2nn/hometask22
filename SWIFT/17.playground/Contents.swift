/* –®–∞—Ö–º–∞—Ç–Ω–∞—è –¥–æ—Å–∫–∞ (–õ–µ–≥–∫–∏–π —É—Ä–æ–≤–µ–Ω—å)
 
 1. –°–æ–∑–¥–∞–π—Ç–µ —Ç–∏–ø —à–∞—Ö–º–∞—Ç–Ω–∞—è –¥–æ—Å–∫–∞.
 2. –î–æ–±–∞–≤—å—Ç–µ —Å–∞–±—Å–∫—Ä–∏–ø—Ç, –∫–æ—Ç–æ—Ä—ã–π –≤—ã–¥–∞–µ—Ç —Ü–≤–µ—Ç –∫–ª–µ—Ç–∫–∏ –ø–æ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–µ –∫–ª–µ—Ç–∫–∏ (–±—É–∫–≤–∞ –∏ —Ü–∏—Ñ—Ä–∞).
 3. –ï—Å–ª–∏ —é–∑–µ—Ä –æ—à–∏–±—Å—è –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º–∏ - –≤—ã–¥–∞–≤–∞–π—Ç–µ –Ω–∏–ª
 
 –ö—Ä–µ—Å—Ç–∏–∫–∏ –Ω–æ–ª–∏–∫–∏ (–°—Ä–µ–¥–Ω–∏–π —É—Ä–æ–≤–µ–Ω—å)
 1. –°–æ–∑–¥–∞—Ç—å —Ç–∏–ø, –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—é—â–∏–π —Å–æ–±–æ–π –ø–æ–ª–µ –¥–ª—è –∏–≥—Ä—ã –≤ –∫—Ä–µ—Å—Ç–∏–∫–∏ –Ω–æ–ª–∏–∫–∏
 –ù–∞ –∫–∞–∂–¥–æ–π –∫–ª–µ—Ç–∫–µ –º–æ–∂–µ—Ç –±—ã—Ç—å —Ç–æ–ª—å–∫–æ –æ–¥–Ω–æ –∏–∑ –∑–Ω–∞—á–µ–Ω–∏–π: –ü—É—Å—Ç–æ, –ö—Ä–µ—Å—Ç–∏–∫, –ù–æ–ª–∏–∫
 –î–æ–±–∞–≤—å—Ç–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –∫—Ä–∞—Å–∏–≤–æ —Ä–∞—Å–ø–µ—á–∞—Ç—ã–≤–∞—Ç—å –ø–æ–ª–µ
 2. –î–æ–±–∞–≤—å—Ç–µ —Å–∞–±—Å–∫—Ä–∏–ø—Ç, –∫–æ—Ç–æ—Ä—ã–π —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ –∫–ª–µ—Ç–∫–∏ –ø–æ —Ä—è–¥—É –∏ —Å—Ç–æ–ª–±—Ü—É,
 –ø—Ä–∏—á–µ–º –≤—ã –¥–æ–ª–∂–Ω—ã —Å–ª–µ–¥–∏—Ç—å –∑–∞ —Ç–µ–º, —á—Ç–æ–±—ã –ø—Ä–æ–≥—Ä–∞–º–º–∞ –Ω–µ –ø–∞–¥–∞–ª–∞ –µ—Å–ª–∏ –±—É–¥–µ—Ç –≤–≤–µ–¥–µ–Ω –Ω–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π —Ä—è–¥ –∏–ª–∏ —Å—Ç–æ–ª–±–µ—Ü.
 3. –¢–∞–∫–∂–µ —Å–ª–µ–¥–∏—Ç–µ –∑–∞ —Ç–µ–º, —á—Ç–æ–±—ã –Ω–µ–ª—å–∑—è –±—ã–ª–æ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—Ç—å –∫—Ä–µ—Å—Ç–∏–∫ –ª–∏–±–æ –Ω–æ–ª–∏–∫ —Ç—É–¥–∞, –≥–¥–µ –æ–Ω–∏ —É–∂–µ —á—Ç–æ-—Ç–æ –µ—Å—Ç—å. –î–æ–±–∞–≤—å—Ç–µ –º–µ—Ç–æ–¥ –æ—á–∏—Å—Ç–∫–∏ –ø–æ–ª—è.
 4. –ï—Å–ª–∏ —Ö–æ—Ç–∏—Ç–µ, –¥–æ–±–∞–≤—Ç–µ –∞–ª–≥–æ—Ä–∏—Ç–º, –∫–æ—Ç–æ—Ä—ã–π –≤—ã—á–∏—Å–ª–∏—Ç –ø–æ–±–µ–¥–∏—Ç–µ–ª—è
 
 –ú–æ—Ä—Å–∫–æ–π –±–æ–π (–¢—è–∂–µ–ª—ã–π —É—Ä–æ–≤–µ–Ω—å)
 1. –°–æ–∑–¥–∞–π—Ç–µ —Ç–∏–ø –∫–æ—Ä–∞–±–ª—å, –∫–æ—Ç–æ—Ä—ã–π –±—É–¥–µ—Ç –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—Ç—å —Å–æ–±–æ–π –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫. –í –Ω–µ–º –º–æ–∂–µ—Ç –±—ã—Ç—å –≤–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ–¥–Ω–æ–º–µ—Ä–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç (–ø–æ–ø–∞—Ö–∏–≤–∞–µ—Ç —Å–∞–±—Å–∫—Ä–∏–ø—Ç–æ–º). –ö–æ—Ä–∞–±–ª—å –¥–æ–ª–∂–µ–Ω –ø—Ä–∏–Ω–∏–º–∞—Ç—å –≤—ã—Å—Ç—Ä–µ–ª—ã –ø–æ –ª–æ–∫–∞–ª—å–Ω—ã–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º –∏ –≤—ã—á–∏—Å–ª—è—Ç—å –∫–æ–≥–¥–∞ –æ–Ω —É–±–∏—Ç
 2. –°–æ–∑–¥–∞–π—Ç–µ –¥–≤—É–º–µ—Ä–Ω–æ–µ –ø–æ–ª–µ, –Ω–∞ –∫–æ—Ç–æ—Ä–æ–º –±—É–¥—É—Ç —Ä–∞—Å–ø–æ–ª–∞–≥–∞—Ç—å—Å—è –∫–æ—Ä–∞–±–ª–∏ –≤—Ä–∞–≥–∞. –°—Ç—Ä–µ–ª—è–π—Ç–µ –ø–æ –ø–æ–ª—é –∏ –ø–æ–¥–±–µ–π—Ç–µ –≤—Ä–∞–∂–µ—Å–∫–∏–π —á–µ—Ç—ã—Ä–µ—Ö —Ç—Ä—É–±–Ω–∏–∫ :)
 3. –°–¥–µ–ª–∞–π—Ç–µ –¥–ª—è –ø—Ä–∏–ª–∏—á–∏—è –ø–∞—Ä—É –≤—ã—Å—Ç—Ä–µ–ª–æ–≤ –º–∏–º–æ, –∫—Ä–∞—Å–∏–≤–µ–Ω—å–∫–æ –≤—Å–µ –≤—ã–≤–æ–¥–∏—Ç–µ –Ω–∞ —ç–∫—Ä–∞–Ω :) */

// –ó–∞–¥–∞–Ω–∏–µ 1

struct Chessboard {
    let rows = 1...8
    let columns = ["A", "B", "C", "D", "E", "F", "G", "H"]
    let oddColumns = ["B", "D", "F", "H"]
    
    enum CellColor: String {
        case white = "‚¨ú"
        case black = "‚¨õ"
    }
    
    func isLetterOdd(letter: String) -> Bool {
        return oddColumns.contains(letter) == true ? true : false
    }
    
    subscript(column: String, row: Int) -> String? {
        if columns.contains(column.uppercased()) && rows ~= row {
            if !isLetterOdd(letter: column.uppercased())  {
                return row%2 == 1 ? CellColor.black.rawValue : CellColor.white.rawValue
            } else {
                return row%2 == 1 ? CellColor.white.rawValue : CellColor.black.rawValue
            }
        }
        return nil
    }
}

var chessboard = Chessboard()
chessboard["a", 3]
chessboard["B", 3]
chessboard["123", 14]
chessboard["Z", 1]
chessboard["F", 0]

// –ó–∞–¥–∞–Ω–∏–µ 2
var xTurnIsNow = true
var countOfTurns = 0

struct TicTacToe {
    static let width = 1...3
    static let height = 1...3
    
    struct Coordinate: Hashable {
        var x = Int()
        var y = Int()
    }
    
    enum TypeOfCell: String {
        case x = "‚ùå"
        case o = "‚≠ï"
        case space = "üî≤"
    }
    
    func printField() {
        print()
        for y in TicTacToe.height {
            var currentString = ""
            for x in TicTacToe.width {
                switch gameField[Coordinate(x: x, y: y)] {
                case .x?: currentString += TypeOfCell.x.rawValue + " "
                case .o?: currentString += TypeOfCell.o.rawValue + " "
                case .space?: currentString += TypeOfCell.space.rawValue + " "
                default: break
                }
            }
            print(currentString)
        }
    }
    
    func isCellEmpty(position: Coordinate) -> Bool {
        return gameField[position] == .space ? true : false
    }
    
    func checkWin() -> Int {                  // 0 - –≤—ã–π–≥—Ä–∞–ª X, 1 - –≤—ã–π–≥—Ä–∞–ª O, 2 - –Ω–∏—á—å—è, —Ç.–∫. –ø–æ–ª–µ –∑–∞–ø–æ–ª–Ω–µ–Ω–æ, 3 - –∏–≥—Ä–∞ –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç—Å—è
        
        var countAtVertical = [0, 0]          // countAtVertical[0] - —Å—á–µ—Ç –∑–∞ X, countAtVertical[1] - —Å—á–µ—Ç –∑–∞ –û
        var countAtHorizontal = [0, 0]        // countAtHorizontal[0] - —Å—á–µ—Ç –∑–∞ X, countAtHorizontal[1] - —Å—á–µ—Ç –∑–∞ –û
        
        for y in TicTacToe.height {
            for x in TicTacToe.width {
                let currentKey = Coordinate(x: x, y: y)
                if gameField[currentKey] == .x {
                }
                if gameField[currentKey] == .o {
                    countAtHorizontal[1] += 1
                }
            }
            if countAtHorizontal[0] == 3 {
                return 0
            }
            if countAtHorizontal[1] == 3 {
                return 1
            }
            countAtHorizontal[0] = 0
            countAtHorizontal[1] = 0
        }
        
        for x in TicTacToe.width {
            for y in TicTacToe.height {
                let currentKey = Coordinate(x: x, y: y)
                if gameField[currentKey] == .x {
                    countAtVertical[0] += 1
                }
                if gameField[currentKey] == .o {
                    countAtVertical[1] += 1
                }
            }
            if countAtVertical[0] == 3 {
                return 0
            }
            if countAtVertical[1] == 3 {
                return 1
            }
            countAtVertical[0] = 0
            countAtVertical[1] = 0
        }
        
        // –°—á–∏—Ç–∞–µ–º –Ω–∞ –≥–ª–∞–≤–Ω–æ–π –¥–∏–∞–≥–∞–Ω–∞–ª–∏
        if gameField[Coordinate(x: 1, y: 1)] == .x && gameField[Coordinate(x: 2, y: 2)] == .x && gameField[Coordinate(x: 3, y: 3)] == .x { return 0 }
        if gameField[Coordinate(x: 1, y: 1)] == .o && gameField[Coordinate(x: 2, y: 2)] == .o && gameField[Coordinate(x: 3, y: 3)] == .o { return 1 }
        
        // –°—á–∏—Ç–∞–µ–º –Ω–∞ –ø–æ–±–æ—á–Ω–æ–π –¥–∏–∞–≥–æ–Ω–∞–ª–∏
        if gameField[Coordinate(x: 3, y: 1)] == .x && gameField[Coordinate(x: 2, y: 2)] == .x && gameField[Coordinate(x: 1, y: 3)] == .x { return 0 }
        if gameField[Coordinate(x: 3, y: 1)] == .o && gameField[Coordinate(x: 2, y: 2)] == .o && gameField[Coordinate(x: 1, y: 3)] == .o { return 1 }
        
        if isFieldFilled() { return 2 }
        
        return 3
    }
    
    func isFieldFilled() -> Bool {
        return countOfTurns == 9 ? true : false
    }
    
    func clearField() {
        for x in TicTacToe.height {
            for y in TicTacToe.width {
                gameField[Coordinate(x: x, y: y)] = .space
            }
        }
        xTurnIsNow = true
        print("–ü–æ–ª–µ —É—Å–ø–µ—à–Ω–æ –æ—á–∏—â–µ–Ω–æ")
        printField()
    }
    
    subscript(coordinate: Coordinate) -> String {
        get {
            return ("")
        }
        
        set {
            let symbol = newValue.uppercased()
            let currentKey = Coordinate(x: coordinate.x, y: coordinate.y)
            
            if symbol != "X" && symbol != "O" {
                return print("–û—à–∏–±–∫–∞ –≤–≤–æ–¥–∞")
            }
            
            guard (xTurnIsNow && symbol == "X") || (!xTurnIsNow && symbol == "O") else {
                print("–°–µ–π—á–∞—Å —Ö–æ–¥–∏—Ç –¥—Ä—É–≥–∞—è —Å—Ç–æ—Ä–æ–Ω–∞!")
                return
            }
            
            if TicTacToe.width ~= coordinate.x && TicTacToe.height ~= coordinate.y {
                if isCellEmpty(position: coordinate) {
                    switch xTurnIsNow {
                    case true :
                        if symbol == "X" {
                            xTurnIsNow = false
                            gameField[currentKey] = .x
                            countOfTurns += 1
                        }
                    case false:
                        if symbol == "O" {
                            xTurnIsNow = true
                            gameField[currentKey] = .o
                            countOfTurns += 1
                        }
                    }
                    printField()
                } else {
                    print("–ö–ª–µ—Ç–∫–∞ –∑–∞–Ω—è—Ç–∞ \n")
                }
            } else {
                print("–û—à–∏–±–∫–∞ –≤–≤–æ–¥–∞. x‚àà[1...3], y‚àà[1...3]")
            }
            switch checkWin() {
            case 0:
                print("–ü–æ–±–µ–¥–∞ –∑–∞ ‚ùå")
                print("–ù–æ–≤–æ–µ –ø–æ–ª–µ..")
                clearField()
                countOfTurns = 0
            case 1:
                print("–ü–æ–±–µ–¥–∞ –∑–∞ ‚≠ï")
                print("–ù–æ–≤–æ–µ –ø–æ–ª–µ..")
                clearField()
                countOfTurns = 0
            case 2:
                print("–ù–∏—á—å—è")
                print("–ù–æ–≤–æ–µ –ø–æ–ª–µ..")
                clearField()
                countOfTurns = 0
            default: break
            }
        }
    }
}

var gameField = [TicTacToe.Coordinate : TicTacToe.TypeOfCell]()

func createFieldAtFirstTime() {
    for x in TicTacToe.height {
        for y in TicTacToe.width {
            gameField[TicTacToe.Coordinate(x: x, y: y)] = .space
        }
    }
    print("–ü–æ–ª–µ —É—Å–ø–µ—à–Ω–æ c–æ–∑–¥–∞–Ω–æ!")
}

createFieldAtFirstTime()
// –û—á–µ—Ä–µ–¥–Ω–æ—Å—Ç—å —Ö–æ–¥–æ–≤ - —Å–Ω–∞—á–∞–ª–∞ –•, –∑–∞—Ç–µ–º –û. –ü–æ—Å–ª–µ –ø–æ–±–µ–¥—ã –ø–µ—Ä–≤—ã–π —Ö–æ–¥ –∑–∞ –• !!!

var justField = TicTacToe()
/*justField[TicTacToe.Coordinate(x: 1, y: 1)] = "X"
 justField[TicTacToe.Coordinate(x: 1, y: 2)] = "O"
 justField[TicTacToe.Coordinate(x: 1, y: 3)] = "X"
 justField[TicTacToe.Coordinate(x: 2, y: 1)] = "O"
 justField[TicTacToe.Coordinate(x: 2, y: 2)] = "X"
 justField[TicTacToe.Coordinate(x: 2, y: 3)] = "O"
 justField[TicTacToe.Coordinate(x: 3, y: 1)] = "X"      // –ü–æ–±–µ–¥–∞ –∑–∞ –∏–∫—Å–∞–º–∏, –Ω–æ —Å–ª–µ–¥—É—é—â–∏–π —Ö–æ–¥ –ø—ã—Ç–∞—é—Ç—Å—è –Ω–∞—á–∞—Ç—å —Å –û!
 justField[TicTacToe.Coordinate(x: 3, y: 2)] = "O"
 justField[TicTacToe.Coordinate(x: 3, y: 3)] = "X"*/

/* justField[TicTacToe.Coordinate(x: 2, y: 2)] = "X"
 justField[TicTacToe.Coordinate(x: 3, y: 3)] = "O"
 justField[TicTacToe.Coordinate(x: 2, y: 3)] = "X"
 justField[TicTacToe.Coordinate(x: 1, y: 3)] = "O"
 justField[TicTacToe.Coordinate(x: 1, y: 1)] = "X"
 justField[TicTacToe.Coordinate(x: 1, y: 2)] = "O"
 justField[TicTacToe.Coordinate(x: 3, y: 1)] = "X"
 justField[TicTacToe.Coordinate(x: 2, y: 1)] = "O"
 justField[TicTacToe.Coordinate(x: 3, y: 2)] = "X"  –Ω–∏—á—å—è */

/* justField[TicTacToe.Coordinate(x: 3, y: 3)] = "X"
justField[TicTacToe.Coordinate(x: 3, y: 1)] = "O"
justField[TicTacToe.Coordinate(x: 2, y: 3)] = "X"
justField[TicTacToe.Coordinate(x: 2, y: 2)] = "O"
justField[TicTacToe.Coordinate(x: 1, y: 1)] = "X"
justField[TicTacToe.Coordinate(x: 1, y: 3)] = "O" */

justField[TicTacToe.Coordinate(x: 1, y: 1)] = "X"
justField[TicTacToe.Coordinate(x: 2, y: 1)] = "X"
justField[TicTacToe.Coordinate(x: 3, y: 1)] = "X"
justField[TicTacToe.Coordinate(x: 4, y: 1)] = "O"
justField[TicTacToe.Coordinate(x: 3, y: 1)] = "O"

/*justField[TicTacToe.Coordinate(x: 2, y: 1)] = "O"
justField[TicTacToe.Coordinate(x: 3, y: 1)] = "X"
justField[TicTacToe.Coordinate(x: 1, y: 2)] = "O"
justField[TicTacToe.Coordinate(x: 2, y: 2)] = "X"
justField[TicTacToe.Coordinate(x: 3, y: 2)] = "O"
justField[TicTacToe.Coordinate(x: 2, y: 3)] = "X"
justField[TicTacToe.Coordinate(x: 1, y: 3)] = "O"
justField[TicTacToe.Coordinate(x: 3, y: 3)] = "X"*/
